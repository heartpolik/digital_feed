//###################################################################################################################################################################################################
//###################################################################################################################################################################################################
//###################################################################################################################################################################################################
//########################          ОБРАБОТЧИКИ ПРЕРЫВАНИЙ          #################################################################################################################################
//###################################################################################################################################################################################################
//###################################################################################################################################################################################################
//###################################################################################################################################################################################################

//===================================================================================================================================================================================================
//========================          Обработчик прерывания watchdog-таймера          =================================================================================================================
//===================================================================================================================================================================================================
ISR(WDT_vect) {
  _WDT_TIMER_FLAG = true;       //Зажигаем флаг срабатывания обработчика. Сама обработка выполнится в цикле Loop, т.к. это не критично к задержке и скорости выполнения

  //Пробуем таймер использовать для тахометра
  if (++TachoCycle > 47)    //48 циклов ~0.064 * 48 = 3,072 сек
  {
    //Serial.print("TachoCount="); Serial.print(TachoCount);                          //Для отладки. Требует включить Serial.
    //Количество тиков за интервал измерения в переменной TachoCount
    //CurrentRPM = TachoCount / ENC_LINE_PER_REV * 60 / 3 ;  // 3с интервал измерения
    CurrentRPM = TachoCount / ENC_LINE_PER_REV * 10;
    //Serial.print(" CurrentRPM="); Serial.print(CurrentRPM); Serial.print("\n");      //Для отладки. Требует включить Serial.
    TachoCount = 0;
    TachoCycle = 0;
  }
}

//===================================================================================================================================================================================================
//===============                   Обработчик прерывания INT0                           ============================================================================================================
//===============               РЕЖИМ "РЕЗЬБА" (Thread) ОСИ Z или X                      ============================================================================================================
//===============      Импульс получает от пина PD0#21 (Энкодер шпинделя канал "B")      ============================================================================================================
//===================================================================================================================================================================================================
ISR(INT0_vect)
{
  //Serial.print("INT0\n\r");

  //NEW Перенёс в начало
  if (Z_WORKING_FEED_FLAG == ON)
  {
    Motor_Z_RemovePulse();
  }
  if (X_WORKING_FEED_FLAG == ON)
  {
    Motor_X_RemovePulse();
  }
  //---

  TachoRemovePulse();

  if (!Enc_Ch_A)
  {
    if (!Enc_Ch_B)
    {
      Spindle_Dir = CW;
      //if (++Enc_Pos == ENC_TICK)
      if (++Enc_Pos >= ENC_TICK)                    //Opti: вместо == используется >= без увеличения размера кода. Enc_Pos у нас знаковое
      {
        Enc_Pos = 0;
        TachoSetPulse();
        if (Joy_Z_flag == ON) {
          Z_WORKING_FEED_FLAG = ON;
        } else if (Joy_X_flag == ON) {
          X_WORKING_FEED_FLAG = ON;
        }
      }
    } else {
      Spindle_Dir = CCW;
      if (--Enc_Pos < 0)
      {
        Enc_Pos = ENC_TICK - 1;
        TachoSetPulse();
        if (Joy_Z_flag == ON) {
          Z_WORKING_FEED_FLAG = ON;
        } else if (Joy_X_flag == ON) {
          X_WORKING_FEED_FLAG = ON;
        }
      }
    }
  }
  else    //if (Enc_Ch_A)
  {
    if (!Enc_Ch_B)
    {
      Spindle_Dir = CCW;
      if (--Enc_Pos < 0)
      {
        Enc_Pos = ENC_TICK - 1;
        TachoSetPulse();
        if (Joy_Z_flag == ON) {
          Z_WORKING_FEED_FLAG = ON;
        } else if (Joy_X_flag == ON) {
          X_WORKING_FEED_FLAG = ON;
        }
      }
    } else {
      Spindle_Dir = CW;
      //if (++Enc_Pos == ENC_TICK)
      if (++Enc_Pos >= ENC_TICK)                    //Opti: вместо == используется >= без увеличения размера кода. Enc_Pos у нас знаковое
      {
        Enc_Pos = 0;
        TachoSetPulse();
        if (Joy_Z_flag == ON) {
          Z_WORKING_FEED_FLAG = ON;
        } else if (Joy_X_flag == ON) {
          X_WORKING_FEED_FLAG = ON;
        }
      }
    }
  }

  if (Z_WORKING_FEED_FLAG == ON)
  {
    //OLD Перенёс в начало
    //Motor_Z_RemovePulse();

    if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Joy_Z_flag) )
    {
      if (tmp_Ks_Divisor < tmp_Accel)
      {
        Ks_Count++;
        if (Ks_Count > tmp_Ks_Divisor)
        {
          //OLD
          //Motor_Z_SetPulse();
          //NEW Перенёс в конец
          MotorZ_NeedClear = true;
          //-

          if (Motor_Z_Dir == CW) {
            Motor_Z_Pos ++;
          } else {
            Motor_Z_Pos --;
          }
          Ks_Count = 0;
          //if (++Repeat_Count == REPEAt)
          if (++Repeat_Count >= REPEAt)                    //Opti: вместо == используется >= без увеличения размера кода. Enc_Pos у нас знаковое
          {
            Repeat_Count = 0;
            tmp_Ks_Divisor ++;
          }
        }
      } else {
        Z_WORKING_FEED_FLAG = OFF;
      }
    }
    else
    {
      Ks_Count++;
      if (Ks_Count > tmp_Ks_Divisor)
      {
        //OLD
        //Motor_Z_SetPulse();
        //NEW Перенёс в конец
        MotorZ_NeedClear = true;
        //-

        if (Motor_Z_Dir == CW) {
          Motor_Z_Pos ++;
        } else {
          Motor_Z_Pos --;
        }
        if (tmp_Ks_Divisor > Ks_Divisor)
        {
          Ks_Count = 0;
          //if (++Repeat_Count == REPEAt)
          if (++Repeat_Count >= REPEAt)                    //Opti: вместо == используется >= без увеличения размера кода. Enc_Pos у нас знаковое
          {
            Repeat_Count = 0;
            tmp_Ks_Divisor --;
          }
        } else {
          Km_Count = Km_Count + Km_Divisor;
          if (Km_Count > Km_Divisor)
          {
            Km_Count = Km_Count - 10000;
            Ks_Count = 0;
          } else {
            Ks_Count = 1;
          }
        }
      }
    }
  }

  if (X_WORKING_FEED_FLAG == ON)
  {
    //OLD Перенёс в начало
    //Motor_X_RemovePulse();

    if ( (Motor_X_Dir == CW && Motor_X_Pos > Limit_Pos) || (Motor_X_Dir == CCW && Motor_X_Pos < Limit_Pos) || (!Joy_X_flag) )
    {
      if (tmp_Ks_Divisor < tmp_Accel)
      {
        Ks_Count++;
        if (Ks_Count > tmp_Ks_Divisor)
        {
          //OLD
          //Motor_X_SetPulse();
          //NEW Перенёс в конец
          MotorX_NeedClear = true;
          //-
          if (Motor_X_Dir == CW) {
            Motor_X_Pos ++;
          } else {
            Motor_X_Pos --;
          }
          Ks_Count = 0;
          //if (++Repeat_Count == REPEAt)
          if (++Repeat_Count >= REPEAt)                    //Opti: вместо == используется >= без увеличения размера кода. Enc_Pos у нас знаковое
          {
            Repeat_Count = 0;
            tmp_Ks_Divisor ++;
          }
        }
      } else {
        X_WORKING_FEED_FLAG = OFF;
      }
    }
    else
    {
      Ks_Count++;
      if (Ks_Count > tmp_Ks_Divisor)
      {
        //OLD
        //Motor_X_SetPulse();
        //NEW Перенёс в конец
        MotorX_NeedClear = true;
        //-
        if (Motor_X_Dir == CW) {
          Motor_X_Pos ++;
        } else {
          Motor_X_Pos --;
        }
        if (tmp_Ks_Divisor > Ks_Divisor)
        {
          Ks_Count = 0;
          //if (++Repeat_Count == REPEAt)
          if (++Repeat_Count >= REPEAt)                    //Opti: вместо == используется >= без увеличения размера кода. Enc_Pos у нас знаковое
          {
            Repeat_Count = 0;
            tmp_Ks_Divisor --;
          }
        } else {
          Km_Count = Km_Count + Km_Divisor;
          if (Km_Count > Km_Divisor)
          {
            Km_Count = Km_Count - 10000;
            Ks_Count = 0;
          } else {
            Ks_Count = 1;
          }
        }
      }
    }
  }

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Для режима ДЕЛИЛКА
  if (Mode == Mode_Divider)
  {
    //INT_1 = false;
    //if (INT_0 == true)
    //{
    //  //Произошёл реверс направления вращения на том же INT
    //  //...
    //  Enc_Pos_Divider = 0;
    //} else {
    //Enc_Pos_Divider = 0;
    if (!Enc_Ch_A)
    {
      if (!Enc_Ch_B)                                //прямое вращение
      {
        Enc_Pos_Divider = 0;
#ifdef _DEBUG_DIVIDER
        Serial.print("0 !A !B\n\r");
#endif
      } else {                                      //вращение в обратную сторону
        Enc_Pos_Divider = 1;
#ifdef _DEBUG_DIVIDER
        Serial.print("0 !A B\n\r");
#endif
      }
    } else {
      if (!Enc_Ch_B)                                //вращение в обратную сторону
      {
        Enc_Pos_Divider = 1;
#ifdef _DEBUG_DIVIDER
        Serial.print("0 A !B\n\r");
#endif
      } else {                                      //прямое вращение
        Enc_Pos_Divider = 0;
#ifdef _DEBUG_DIVIDER
        Serial.print("0 A B\n\r");
#endif
      }
    }
    //}
    //INT_0 = true;
    ////Enc_Pos_Divider = 0;
    //DEBUG
#ifdef _DEBUG_DIVIDER
    Serial.print("---\n\r");
    Serial.print("0 Enc_Pos="); Serial.print(Enc_Pos); Serial.print("\n\r");
    Serial.print("0 Enc_Pos_Divider="); Serial.print(Enc_Pos_Divider); Serial.print("\n\r");
    Serial.print("0 Summ="); Serial.print(2 * Enc_Pos + Enc_Pos_Divider); Serial.print("\n\r");
    long Spindle_Angle = (2 * Enc_Pos + Enc_Pos_Divider) * 36000 / (2 * ENC_TICK);
    Serial.print("0 Spindle_Angle="); Serial.print(Spindle_Angle); Serial.print("\n\r");
#endif
    //
  }
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  //NEW Перенёс в конец
  /*
    if (MotorZ_NeedClear)
    {
    _delay_us(30);      //1 000 000 микросекунд в 1 секунде
    Motor_Z_SetPulse();

    }
    if (MotorX_NeedClear)
    {
    if (!MotorZ_NeedClear) _delay_us(30);   //Если задержка уже была по оси Z - то не надо повтора.
    Motor_X_SetPulse();

    }
    MotorZ_NeedClear = false;                 //Пока это глобальные флаги, но на финале можно их сделать локальными, тогда и сбрасывать в false не придётся
    MotorX_NeedClear = false;

    //---
  */
}

//===================================================================================================================================================================================================
//===============                   Обработчик прерывания INT1                           ============================================================================================================
//===============      Импульс получает от пина PD1#20 (Энкодер шпинделя канал "A")      ============================================================================================================
//===================================================================================================================================================================================================
ISR(INT1_vect)
{
  //
  //Serial.print("INT1\n\r");
  ++TachoCount;
  //Serial.print(TachoCount);Serial.print("\n\r");

  /*
    if (MotorZ_NeedClear)
    {
    Motor_Z_RemovePulse();
    MotorZ_NeedClear = false;
    }
    if (MotorX_NeedClear)
    {
    Motor_X_RemovePulse();
    MotorX_NeedClear = false;
    }
  */

  if (MotorZ_NeedClear)
  {
    Motor_Z_SetPulse();
#ifdef _DEBUG_INTERRUPT
    Serial.print("Z1\n\r");       //DEBUG
#endif
    MotorZ_NeedClear = false;
  }
  if (MotorX_NeedClear)
  {
    Motor_X_SetPulse();
#ifdef _DEBUG_INTERRUPT
    Serial.print("X1\n\r");       //DEBUG
#endif
    MotorX_NeedClear = false;
  }

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Для режима ДЕЛИЛКА
  if (Mode == Mode_Divider)
  {
    //INT_0 = false;
    //if (INT_1 == true)
    //{
    //  //Произошёл реверс направления вращения на том же INT
    //  //...
    //  Enc_Pos_Divider = 0;
    //} else {
    if (!Enc_Ch_A)
    {
      if (!Enc_Ch_B)                                //вращение в обратную сторону
      {
        Enc_Pos_Divider = 0;  //-1
#ifdef _DEBUG_DIVIDER
        Serial.print("1 !A !B\n\r");
#endif
      } else {
        Enc_Pos_Divider = 1;
#ifdef _DEBUG_DIVIDER
        Serial.print("1 !A B\n\r");
#endif
      }
    } else {
      if (!Enc_Ch_B)
      {
        Enc_Pos_Divider = 1;
#ifdef _DEBUG_DIVIDER
        Serial.print("1 A !B\n\r");
#endif
      } else {                                      //вращение в обратную сторону
        Enc_Pos_Divider = 0;      //-1;
#ifdef _DEBUG_DIVIDER
        Serial.print("1 A B\n\r");
#endif
      }
    }
    //}
    //INT_1 = true;

    //DEBUG
#ifdef _DEBUG_DIVIDER
    Serial.print("---\n\r");
    Serial.print("1 Enc_Pos="); Serial.print(Enc_Pos); Serial.print("\n\r");
    Serial.print("1 Enc_Pos_Divider="); Serial.print(Enc_Pos_Divider); Serial.print("\n\r");
    Serial.print("1 Summ="); Serial.print(2 * Enc_Pos + Enc_Pos_Divider); Serial.print("\n\r");
    long Spindle_Angle = (2 * Enc_Pos + Enc_Pos_Divider) * 36000 / (2 * ENC_TICK);
    Serial.print("1 Spindle_Angle="); Serial.print(Spindle_Angle); Serial.print("\n\r");
#endif
    //
  }
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

}

//===================================================================================================================================================================================================
//============                      Обработчик прерывания INT2                       ================================================================================================================
//============                 РУЧНОЙ ЭНКОДЕР (ГЕНЕРАТОР ИМПУЛЬСОВ)                  ================================================================================================================
//============        Генерируется от пина PD2#19 при любом изменении сигнала        ================================================================================================================
//===================================================================================================================================================================================================
//После Opti выигрыш 4 байт
ISR(INT2_vect)
{
  //Было вот так
  /*
    if (!Hand_Ch_A)
    {
       if (!Hand_Ch_B) {Hand_Count --;}
    }

    else
    {
       if (!Hand_Ch_B) {Hand_Count ++;}
    }
  */

  //Переписываем вот так    //Opti Выигрыш 4 байт

  if (!Hand_Ch_B)           //PD3#18 == 0
  {
    if (!Hand_Ch_A)         //PD2#19 == 0
    {
      Hand_Count --;
    } else {                //PD2#19 == 1
      Hand_Count ++;
    }
  }

  /*
    //NEW2 Ещё более упрощённый код, но он потребовал изменения в файле DEFINE.h строки INT2_Init()
    if (!Hand_Ch_B)           //PD3#18 == 0
    {
    Hand_Count --;
    } else {
    Hand_Count ++;
    }
  */
  //DEBUG
  //Serial.print("Hand_Count=");Serial.print(Hand_Count);Serial.print("\n\r");
}

//###################################################################################################################################################################################################
//###################################################################################################################################################################################################
//###################################################################################################################################################################################################
//########################          ОБРАБОТЧИКИ ТАЙМЕРОВ          ###################################################################################################################################
//###################################################################################################################################################################################################
//###################################################################################################################################################################################################
//###################################################################################################################################################################################################

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER0_COMPB        =============================================================================================================================
//========================              *****  Tacho *****              =============================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER0_COMPB_vect)                                 // Тахометр
{
  //
}

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER2_COMPA        =============================================================================================================================
//========================              НЕ ИСПОЛЬЗУЕТСЯ                 =============================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER2_COMPA_vect)
{
  //
}

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER2_COMPB        =============================================================================================================================
//========================              НЕ ИСПОЛЬЗУЕТСЯ                 =============================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER2_COMPB_vect)
{
  //
}

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER3_COMPA        =============================================================================================================================
//========================       РУЧНОЙ ЭНКОДЕР ПЕРЕМЕЩЕНИЕ ОСЬ Z       =============================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER3_COMPA_vect)
{
  //---------------------------------------------------------------------------------------------------------------------------------------------------------
  //Доработка: Чтобы на масштабе ручного энкодера Х10 нельзя было выехать за установленные лимиты
  if (flag_Scale_x10 == ON)
  {
    if (Motor_Z_Dir == CW)                  //CW
    {
      if (Motor_Z_Pos >= Limit_Pos_Left)
      {
        return;
      }
    } else {                                //CCW
      if (Motor_Z_Pos <= Limit_Pos_Right)
      {
        return;
      }
    }
  }
  //---------------------------------------------------------------------------------------------------------------------------------------------------------
  //Opti: Выполняем предварительное вычисление, т.к.оно используется в дальнейшем
  long NullHand_Z_Pos = Null_Z_Pos + Hand_Z_Pos;

  if (Motor_Z_Dir == CW)
  {
    //if (Motor_Z_Pos < Null_Z_Pos + Hand_Z_Pos)
    if (Motor_Z_Pos < NullHand_Z_Pos)                       //Opti:
    {
      Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
      Serial.print("Z3A\n\r");       //DEBUG
#endif
      if (!Read_Z_State)
      {
        Motor_Z_Pos ++;
        if ((Motor_Z_Pos > Limit_Pos_HC) || (hand_Z == OFF))
        {
          if (OCR3A < max_OCR3A) OCR3A ++;
        }
        else if (Motor_Z_Pos < Limit_Pos_HC)
        {
          if (OCR3A > min_OCR3A) OCR3A --;
        }
      }
    }
    //else if (Motor_Z_Pos == Hand_Z_Pos)                         //Opti: Участок не используется Олегом. Отключение не даёт выигрыша, т.к. компилятор сам удаляет бессмысленные участи кода
    //{
    //  //
    //}
  }
  //else if (Motor_Z_Dir == CCW)
  else                                                      //Opti: Motor_Z_Dir это битовая переменная, всего два состояния, проверять второе при несоответствии 1 бессмысленно. Выигрыш = 60 байт
  {
    //if (Motor_Z_Pos > Null_Z_Pos + Hand_Z_Pos)
    if (Motor_Z_Pos > NullHand_Z_Pos)                       //Opti:
    {
      Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
      Serial.print("Z3A\n\r");       //DEBUG
#endif
      if (!Read_Z_State)
      {
        Motor_Z_Pos --;
        //if (Motor_Z_Pos < Limit_Pos_HC  || hand_Z == OFF)
        if ((Motor_Z_Pos < Limit_Pos_HC) || (hand_Z == OFF))          //Opti: Просто добавил скобки как в остальных аналогичных проверках
        {
          if (OCR3A < max_OCR3A) OCR3A ++;
        }
        else if (Motor_Z_Pos > Limit_Pos_HC)
        {
          if (OCR3A > min_OCR3A) OCR3A --;
        }
      }
    }
    //else if (Motor_Z_Pos == Hand_Z_Pos)                         //Opti: Участок не используется Олегом. Отключение не даёт выигрыша, т.к. компилятор сам удаляет бессмысленные участи кода
    //{
    //  //
    //}
  }
}

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER3_COMPB        =============================================================================================================================
//========================       РУЧНОЙ ЭНКОДЕР ПЕРЕМЕЩЕНИЕ ОСЬ X       =============================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER3_COMPB_vect)
{
  //---------------------------------------------------------------------------------------------------------------------------------------------------------
  //Доработка: Чтобы на масштабе ручного энкодера Х10 нельзя было выехать за установленные лимиты
  if (flag_Scale_x10 == ON)
  {
    if (Motor_Z_Dir == CW)                  //CW
    {
      if (Motor_X_Pos >= Limit_Pos_Front)
      {
        return;
      }
    } else {                                //CCW
      if (Motor_X_Pos <= Limit_Pos_Rear)
      {
        return;
      }
    }
  }
  //---------------------------------------------------------------------------------------------------------------------------------------------------------
  //Opti: Выполняем предварительное вычисление, т.к.оно используется в дальнейшем
  long NullHand_X_Pos = Null_X_Pos + Hand_X_Pos;

  if (Motor_X_Dir == CW)
  {
    //if (Motor_X_Pos < Null_X_Pos + Hand_X_Pos)
    if (Motor_X_Pos < NullHand_X_Pos)                           //Opti:
    {
      Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
      Serial.print("X3B\n\r");       //DEBUG
#endif
      if (!Read_X_State)
      {
        Motor_X_Pos ++;
        if ((Motor_X_Pos > Limit_Pos_HC) || (hand_X == OFF))
        {
          if (OCR3A < max_OCR3A) OCR3A ++;
        }
        else if (Motor_X_Pos < Limit_Pos_HC)
        {
          if (OCR3A > min_OCR3A) OCR3A --;
        }
      }
    }
    //else if (Motor_X_Pos == Hand_X_Pos)                         //Opti: Участок не используется Олегом. Отключение не даёт выигрыша, т.к. компилятор сам удаляет бессмысленные участи кода
    //{
    //  //
    //}
  }
  //else if (Motor_X_Dir == CCW)
  else                                                      //Opti: Motor_X_Dir это битовая переменная, всего два состояния, проверять второе при несоответствии 1 бессмысленно. Выигрыш = 60 байт
  {
    //if (Motor_X_Pos > Null_X_Pos + Hand_X_Pos)
    if (Motor_X_Pos > NullHand_X_Pos)                           //Opti:
    {
      Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
      Serial.print("X3B\n\r");       //DEBUG
#endif
      if (!Read_X_State)
      {
        Motor_X_Pos --;
        if ((Motor_X_Pos < Limit_Pos_HC) || (hand_X == OFF))
        {
          if (OCR3A < max_OCR3A) OCR3A ++;
        }
        else if (Motor_X_Pos > Limit_Pos_HC)
        {
          if (OCR3A > min_OCR3A) OCR3A --;
        }
      }
    }
    //else if (Motor_X_Pos == Hand_X_Pos)                         //Opti: Участок не используется Олегом. Отключение не даёт выигрыша, т.к. компилятор сам удаляет бессмысленные участи кода
    //{
    //  //
    //}
  }
}

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER4_COMPA        =============================================================================================================================
//========================  РЕЖИМ "АСИНХРОННАЯ ПОДАЧА" (aFeed) ОСЬ Z    =============================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER4_COMPA_vect)
{
  //Serial.print("4A\n\r");
  //-------------------------------------------------------------------------------------------------------------------------------------------
  if (Joy_Z_flag == ON) {
    Motor_X_RemovePulse();
  }
  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]
  bool bRapid = false;

  if (SpeedMode == FORCE_RAPID)
  {
    //Режим работы постоянный Rapid - аналог функции который у Олега работал на OCR2A таймере - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах и при запуске с включённой кнопкой RapidButton)
    bRapid = true;
  } else if (SpeedMode == FORCE_SLOW)
  {
    //Режим работы постоянный Slow - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах)
    bRapid = false;
  } else {
    //Режим работы Manual - производит опрос кнопки RapidButton и переключается между режимами Rapid и Slow, можно прямо во время работы
    //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]

    /*
      //Сначала проверка условия на кнопку ускоренной подачи. Истинно, если кнопка "Быстрая подача" не нажата.
      if (Button_Rapid_Not_Pressed)                           //КНОПКА "БЫСТРАЯ ПОДАЧА" не нажата
      {
      if (Z_NEED_RUN_RAPID_FLAG == ON && Z_WORKING_RAPID_FLAG == ON)    //Если мотор Z не в простое, а был в работе, в режиме подача:
      {
        Z_WORKING_FEED_FLAG = ON;                                   //то включаем флаги режима обычной подачи
        Z_NEED_RUN_FEED_FLAG = ON;
        Z_NEED_RUN_RAPID_FLAG = OFF;                                 //и выключаем флаги быстрой подачи (это можно делать прям на ходу)
        Z_WORKING_RAPID_FLAG = OFF;
      } else if (Z_NEED_RUN_RAPID_FLAG == ON && Z_NEED_RUN_FEED_FLAG == OFF)  //Это "костыль" - когда нажат Рапид и двигатель доехал до лимита, и рапид отпускают, а джой всё-ещё в положении движения - чтобы мотор не сдвинулся с лимита (не переключился на торможение в режиме подача)
      {
        OCR4A = max_OCR4A;    //Чтобы мотор при переходе с быстрой подачи на обычную при достижении лимита не "тормозил" повторно и не выезжал за лимит
      }
      } else {                                                //КНОПКА "БЫСТРАЯ ПОДАЧА" нажата
      if (Z_WORKING_FEED_FLAG == ON && Z_NEED_RUN_FEED_FLAG == ON)           //Если мотор Z не в простое, а был в работе, в режиме подача:
      {
        Z_WORKING_FEED_FLAG = OFF;                                  //то выключаем флаги режима обычной подачи
        Z_NEED_RUN_FEED_FLAG = OFF;
        Z_NEED_RUN_RAPID_FLAG = ON;                                  //и включаем флаги в режим быстрой подачи (это можно делать прям на ходу)
        Z_WORKING_RAPID_FLAG = ON;
      }
      bRapid = true;                                        //Обнаружено нажатие на кнопку ускоренной подачи, взводим флаг и в дальнейшем используем этот флаг вместо чтения пина кнопки
      }
    */

  }


  //-------------------------------------------------------------------------------------------------------------------------------------------
  if (Mode == Mode_aFeed)
  {
    if (bRapid)     //РЕЖИМ БЫСТРОЙ ПОДАЧИ
    {
      //-------------------------------------------------------------------------------------------------------------------------------------------
      if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Z_NEED_RUN_RAPID_FLAG) )
      {
        if (OCR4A < (unsigned int)MIN_RAPID_MOTION)               //Переделка OCR2A -> OCR4A (unsigned int)
        {
          Motor_Z_InvertPulse();
          //Serial.print("Z4A\n\r");       //DEBUG
#ifdef _DEBUG_INTERRUPT
          Serial.print("\n\rZ4A "); Serial.print(OCR4A);
#endif
          //Serial.print("Motor_Z_InvertPulse\n\r");
          if (!Read_Z_State)
          {
            if (Motor_Z_Dir == CW) {
              Motor_Z_Pos ++;
            } else {
              Motor_Z_Pos --;
            }
            if (++Repeat_Count >= REPEAt)                           //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR4A ++;                                             //Переделка OCR2A -> OCR4A
            }
          }
        } else {
          Z_WORKING_RAPID_FLAG = OFF;
          X_WORKING_FEED_FLAG = OFF;
        }
      }
      else
      {
        Z_WORKING_RAPID_FLAG = ON;
        Motor_Z_InvertPulse();
        //Serial.print("Z4A\n\r");       //DEBUG
#ifdef _DEBUG_INTERRUPT
        Serial.print("\n\rz4A "); Serial.print(OCR4A);
#endif
        //Serial.print("Motor_Z_InvertPulse\n\r");
        if (!Read_Z_State)
        {
          if (Motor_Z_Dir == CW) {
            Motor_Z_Pos ++;
          } else {
            Motor_Z_Pos --;
          }
          if (OCR4A > (unsigned int)MAX_RAPID_MOTION)                 //Переделка OCR2A -> OCR4A (unsigned int)
          {
            if (++Repeat_Count >= REPEAt)                             //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR4A --;                                               //Переделка OCR2A -> OCR4A
            }
          }
        }
      }
      //-------------------------------------------------------------------------------------------------------------------------------------------
    } else {        //РЕЖИМ ОБЫЧНОЙ АСИНХРОННОЙ ПОДАЧИ
      //Три условия выполнения участка кода:
      //Мотор оси Z достиг Левого лимита (Независимо от положения ручки джойстика программная команда на СТОП)
      //Мотор оси Z достиг Правого лимита (Независимо от положения ручки джойстика программная команда на СТОП)
      //Погашен флаг работы по оси Z (обычно от ручки джойстика в нейтральном положении)
      if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Z_NEED_RUN_FEED_FLAG) )
      {
        //Участок замедления, торможения скорости вращения мотора по оси Z (до минимальной заданной)
        if (OCR4A < max_OCR4A)
        {
          Motor_Z_InvertPulse();                  //Смена состояния линии PULSE оси Z
          //Serial.print("Z4A\n\r");       //DEBUG
#ifdef _DEBUG_INTERRUPT
          Serial.print("\n\rZ4a "); Serial.print(OCR4A);
#endif
          //Serial.print("Motor_Z_InvertPulse\n\r");
          if (!Read_Z_State)                      //Выполняем через раз - когда Read_Z_State возвращает false
          {
            OCR4A ++;                             //Замедление, торможение, снижение скорости вращения - путём снижения частоты работы таймера OCR4A
            if (Motor_Z_Dir == CW) {              //Выясняем текущее направление вращения мотора оси Z
              Motor_Z_Pos ++;                     //Учёт, подсчёт импульса в зависимости от направления вращения
            } else {
              Motor_Z_Pos --;                     //Учёт, подсчёт импульса в зависимости от направления вращения
            }
          }
        }
        else      //по достижению минимальной заданной скорости - выключаются флаги работы моторов по всем осям
        {
          Z_WORKING_FEED_FLAG = OFF;                      //После выполнения торможения - зажигаем флаги остановки (вернее гасим флаги работы по оси Z)
          X_WORKING_FEED_FLAG = OFF;                      //После выполнения торможения - зажигаем флаги остановки (вернее гасим флаги работы по оси X)
        }
      }
      else
      {
        Z_WORKING_FEED_FLAG = ON;                         //Зажигаем флаг работы по оси Z
        Motor_Z_InvertPulse();                    //Смена состояния линии PULSE оси Z
        //Serial.print("Z4A\n\r");       //DEBUG
#ifdef _DEBUG_INTERRUPT
        Serial.print("\n\rz4a "); Serial.print(OCR4A);
#endif
        //Serial.print("Motor_Z_InvertPulse\n\r");
        if (!Read_Z_State)                        //Выполняем через раз - когда Read_Z_State возвращает false
        {
          if (Motor_Z_Dir == CW) {                //Выясняем текущее направление вращения мотора оси Z
            Motor_Z_Pos ++;                       //Учёт, подсчёт импульса в зависимости от направления вращения
          } else {
            Motor_Z_Pos --;                       //Учёт, подсчёт импульса в зависимости от направления вращения
          }
          if (OCR4A > aFeed_Divisor) {            //Сравнение текущей частоты таймера OCR4 с заданной частотой aFeed_Divisor (зависит от положения ручки переменного резистора подач)
            OCR4A --;                             //Ускорение, разгон, набор скорости вращения - путём увеличения частоты работы таймера OCR4A
          } else if (OCR4A < aFeed_Divisor) {
            OCR4A ++;                             //Замедление, торможение, снижение скорости вращения - путём снижения частоты работы таймера OCR4A
          }
        }
      }

    }
  }
  //test
  TIFR4 = 0x00;
  //-------------------------------------------------------------------------------------------------------------------------------------------
}

//===================================================================================================================================================================================================
//========================       Обработчик таймера TIMER4_COMPB        =============================================================================================================================
//=====    РЕЖИМ "АСИНХРОННАЯ ПОДАЧА" (aFeed) и новый РЕЖИМ "АСИНХРОННЫЙ КОНУС" (Cone_L Cone_R) ОСЬ X    ============================================================================================
//===================================================================================================================================================================================================
ISR (TIMER4_COMPB_vect)
{
  //Serial.print("4B\n\r");
  //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]
  bool bRapid = false;



  if (SpeedMode == FORCE_RAPID)
  {
    //Режим работы постоянный Rapid - аналог функции который у Олега работал на OCR2A таймере - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах и при запуске с включённой кнопкой RapidButton)
    bRapid = true;
  } else if (SpeedMode == FORCE_SLOW)
  {
    //Режим работы постоянный Slow - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах)
    bRapid = false;
  } else {
    //Режим работы Manual - производит опрос кнопки RapidButton и переключается между режимами Rapid и Slow, можно прямо во время работы
    //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]



    /*
      //Сначала проверка условия на кнопку ускоренной подачи. Истинно, если кнопка "Быстрая подача" не нажата.
      if (Button_Rapid_Not_Pressed)                           //КНОПКА "БЫСТРАЯ ПОДАЧА" не нажата
      {
      if (X_NEED_RUN_RAPID_FLAG == ON && X_WORKING_RAPID_FLAG == ON)    //Если мотор X не в простое, а был в работе, в режиме подача:
      {
        X_WORKING_FEED_FLAG = ON;                                   //то включаем флаги режима обычной подачи
        X_NEED_RUN_FEED_FLAG = ON;
        X_NEED_RUN_RAPID_FLAG = OFF;                                 //и выключаем флаги быстрой подачи (это можно делать прям на ходу)
        X_WORKING_RAPID_FLAG = OFF;
      }
      } else {                                                //КНОПКА "БЫСТРАЯ ПОДАЧА" нажата
      if (X_WORKING_FEED_FLAG == ON && X_NEED_RUN_FEED_FLAG == ON)           //Если мотор X не в простое, а был в работе, в режиме подача:
      {
        X_WORKING_FEED_FLAG = OFF;                                  //то выключаем флаги режима обычной подачи
        X_NEED_RUN_FEED_FLAG = OFF;
        X_NEED_RUN_RAPID_FLAG = ON;                                  //и включаем флаги в режим быстрой подачи (это можно делать прям на ходу)
        X_WORKING_RAPID_FLAG = ON;
      }
      bRapid = true;                                        //Обнаружено нажатие на кнопку ускоренной подачи, взводим флаг и в дальнейшем используем этот флаг вместо чтения пина кнопки
      }
    */

  }


  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Таймер4 для двух режимов aFeed и Конусов
  if (Mode == Mode_aFeed || Mode == Mode_Cone_L || Mode == Mode_Cone_R)
  {
    if (bRapid)       //РЕЖИМ БЫСТРОЙ ПОДАЧИ
    {
      if ( (Motor_X_Dir == CW && Motor_X_Pos > Limit_Pos) || (Motor_X_Dir == CCW && Motor_X_Pos < Limit_Pos) || (!X_NEED_RUN_RAPID_FLAG) )
      {
        if (OCR4A < (unsigned int)MIN_RAPID_MOTION)     //OCR2A -> OCR4B? + ->(unsigned int)
        {
          Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
          Serial.print("X4B\n\r");       //DEBUG
#endif
          if (!Read_X_State)
          {
            if (Motor_X_Dir == CW) {
              Motor_X_Pos ++;
            } else {
              Motor_X_Pos --;
            }
            if (++Repeat_Count >= REPEAt)                 //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR4A ++;
            }
          }
        } else {
          X_WORKING_RAPID_FLAG = OFF;
        }
      }
      else
      {
        X_WORKING_RAPID_FLAG = ON;
        Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("X4B\n\r");       //DEBUG
#endif
        if (!Read_X_State)
        {
          if (Motor_X_Dir == CW) {
            Motor_X_Pos ++;
          }
          else {
            Motor_X_Pos --;
          }
          if (OCR4A > (unsigned int)MAX_RAPID_MOTION)     //OCR2A -> OCR4B? + ->(unsigned int)
          {
            if (++Repeat_Count >= REPEAt)       //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR4A --;
            }
          }
        }
      }
    }
    else            //РЕЖИМ ОБЫЧНОЙ ПОДАЧИ
    {
      if ( (Motor_X_Dir == CW && Motor_X_Pos > Limit_Pos) || (Motor_X_Dir == CCW && Motor_X_Pos < Limit_Pos) || (!X_NEED_RUN_FEED_FLAG) )
      {
        if (OCR4A < max_OCR4A)
        {
          Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
          Serial.print("X4B\n\r");       //DEBUG
#endif
          if (!Read_X_State)
          {
            OCR4A ++;
            if (Motor_X_Dir == CW) {
              Motor_X_Pos ++;
            } else {
              Motor_X_Pos --;
            }
          }
        } else {
          Z_WORKING_FEED_FLAG = OFF;
          X_WORKING_FEED_FLAG = OFF;
        }
      } else
      {
        X_WORKING_FEED_FLAG = ON;
        Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("X4B\n\r");       //DEBUG
#endif
        if (!Read_X_State)
        {
          if (Motor_X_Dir == CW) {
            Motor_X_Pos ++;
          } else {
            Motor_X_Pos --;
          }
          if (OCR4A > aFeed_Divisor) {
            OCR4A --;
          } else if (OCR4A < aFeed_Divisor) {
            OCR4A ++;
          }
        }
      }

    }

  }
  //-------------------------------------------------------------------------------------------------------------------------------------------
}

//===================================================================================================================================================================================================
//=============                  Обработчик таймера TIMER4_COMPC                =====================================================================================================================
//=============      новый РЕЖИМ "АСИНХРОННЫЙ КОНУС" (Cone_L Cone_R) ОСЬ Z      =====================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER4_COMPC_vect)
{
  //Serial.print("4C\n\r");
  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Если коэффициент конуса меньше 2.0000, то частоты не хватает и импульсы получаются слишком короткими
  if (XZ_Divisor == (byte)0)
  {
    if (Cs_Divisor < (byte)2)
    {
      if (MotorX_NeedClear)
      {
        Motor_X_RemovePulse();
        MotorX_NeedClear = false;

        //DEBUG
        //Serial.print("X_RemovePulse Force\n\r");

        return; //Т.к. режим асинхронный - можно позволить пропустить тик и подождать немного перед следующим поднятием импульса Х - для того чтобы импульсы были шире по фронту и не пропускались драйвером,
        //фактическая скорость перемещения немного падает, но убираются пропуски импульсов драйвером при Конусах с коэффициентами меньше 2.0000 и больше 1.0000
      }
      //if (MotorZ_NeedClear)
      //{
      //  Motor_Z_RemovePulse();
      //  MotorZ_NeedClear = false;
      //  Serial.print("Z_RemovePulse Force\n\r");
      //  return; //Т.к. режим асинхронный - можно позволить пропустить тик и подождать немного перед следующим поднятием импульса Z - для того чтобы импульсы были шире по фронту и не пропускались драйвером,
      //  //фактическая скорость перемещения немного падает, но убираются пропуски импульсов драйвером при Конусах с коэффициентами меньше 2.0000 и больше 1.0000
      //}
    } else {
      Motor_X_RemovePulse();
    }
  } else {

  }

  //-------------------------------------------------------------------------------------------------------------------------------------------

  bool bRapid = false;

  if (SpeedMode == FORCE_RAPID)
  {
    //Режим работы постоянный Rapid - аналог функции который у Олега работал на OCR2A таймере - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах и при запуске с включённой кнопкой RapidButton)
    bRapid = true;
  } else if (SpeedMode == FORCE_SLOW)
  {
    //Режим работы постоянный Slow - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах)
    bRapid = false;
  } else {
    //Режим работы Manual - производит опрос кнопки RapidButton и переключается между режимами Rapid и Slow, можно прямо во время работы
    //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]

    /*
      //Сначала проверка условия на кнопку ускоренной подачи. Истинно, если кнопка "Быстрая подача" не нажата.
      if (Button_Rapid_Not_Pressed)                           //КНОПКА "БЫСТРАЯ ПОДАЧА" не нажата
      {
      if (Z_NEED_RUN_RAPID_FLAG == ON && Z_WORKING_RAPID_FLAG == ON)    //Если мотор Z не в простое, а был в работе, в режиме подача:
      {
        Z_WORKING_FEED_FLAG = ON;                                   //то включаем флаги режима обычной подачи
        Z_NEED_RUN_FEED_FLAG = ON;
        Z_NEED_RUN_RAPID_FLAG = OFF;                                 //и выключаем флаги быстрой подачи (это можно делать прям на ходу)
        Z_WORKING_RAPID_FLAG = OFF;
      } else if (Z_NEED_RUN_RAPID_FLAG == ON && Z_NEED_RUN_FEED_FLAG == OFF)  //Это "костыль" - когда нажат Рапид и двигатель доехал до лимита, и рапид отпускают, а джой всё-ещё в положении движения - чтобы мотор не сдвинулся с лимита (не переключился на торможение в режиме подача)
      {
        OCR4A = max_OCR4A;    //Чтобы мотор при переходе с быстрой подачи на обычную при достижении лимита не "тормозил" повторно и не выезжал за лимит
      }
      } else {                                                //КНОПКА "БЫСТРАЯ ПОДАЧА" нажата
      if (Z_WORKING_FEED_FLAG == ON && Z_NEED_RUN_FEED_FLAG == ON)           //Если мотор Z не в простое, а был в работе, в режиме подача:
      {
        Z_WORKING_FEED_FLAG = OFF;                                  //то выключаем флаги режима обычной подачи
        Z_NEED_RUN_FEED_FLAG = OFF;
        Z_NEED_RUN_RAPID_FLAG = ON;                                  //и включаем флаги в режим быстрой подачи (это можно делать прям на ходу)
        Z_WORKING_RAPID_FLAG = ON;
      }
      bRapid = true;                                        //Обнаружено нажатие на кнопку ускоренной подачи, взводим флаг и в дальнейшем используем этот флаг вместо чтения пина кнопки
      }
    */



  }


  //-------------------------------------------------------------------------------------------------------------------------------------------
  //ДЕЛИТЕЛЬ ИМПУЛЬСОВ ДЛЯ ОСИ Z (Только режим КОНУСОВ + признак XZ_Divisor == 1)
  if (XZ_Divisor == (byte)1)
  {
    if (Z_WORKING_FEED_FLAG == ON)
    {
      if (++Cs_Count > Cs_Divisor)            //Если текущий счётчик целой части конуса больше Коэффициента конуса из таблицы конусов (целая часть)
      {
        Cm_Count = Cm_Count + Cm_Divisor;     //
        if (Cm_Count > Cm_Divisor) {          //
          Cm_Count = Cm_Count - 10000;        //
          Cs_Count = 0;                       //Сброс Cs_Count до 0
        } else {
          Cs_Count = 1;                       //Иначе сброс Cs_Count до 1
        }
        //goto AXIS_Z;
      } else {
        //Пропуск тика по Z
        goto AXIS_X;
      }
    }
  }

  //AXIS_Z:





  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Таймер4 для двух режимов aFeed и Конусов
  //if (Mode == Mode_aFeed || Mode == Mode_Cone_L || Mode == Mode_Cone_R)
  //{
  if (bRapid)     //РЕЖИМ БЫСТРОЙ ПОДАЧИ
  {
    //-------------------------------------------------------------------------------------------------------------------------------------------
    //Motor_X_RemovePulse();      //Убрал т.к. в начале уже есть код
    if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Z_NEED_RUN_RAPID_FLAG) )
    {
      if (OCR4A < (unsigned int)MIN_RAPID_MOTION)               //Переделка OCR2A -> OCR4A (unsigned int)
      {
        Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("Z4C\n\r");       //DEBUG
#endif
        //Serial.print("Motor_Z_InvertPulse\n\r");
        if (!Read_Z_State)
        {
          if (Motor_Z_Dir == CW) {
            Motor_Z_Pos ++;
          } else {
            Motor_Z_Pos --;
          }
          if (++Repeat_Count >= REPEAt)                           //Opti: вместо == используется >= без увеличения размера кода
          {
            Repeat_Count = 0;
            OCR4A ++;                                             //Переделка OCR2A -> OCR4A
          }
        }
      } else {
        Z_WORKING_RAPID_FLAG = OFF;
        X_WORKING_FEED_FLAG = OFF;
      }
    }
    else
    {
      Z_WORKING_RAPID_FLAG = ON;
      Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
      Serial.print("Z4C\n\r");       //DEBUG
#endif
      //Serial.print("Motor_Z_InvertPulse\n\r");
      if (!Read_Z_State)
      {
        if (Motor_Z_Dir == CW) {
          Motor_Z_Pos ++;
        } else {
          Motor_Z_Pos --;
        }
        if (OCR4A > (unsigned int)MAX_RAPID_MOTION)                 //Переделка OCR2A -> OCR4A (unsigned int)
        {
          if (++Repeat_Count >= REPEAt)                             //Opti: вместо == используется >= без увеличения размера кода
          {
            Repeat_Count = 0;
            OCR4A --;                                               //Переделка OCR2A -> OCR4A
          }
        }
      }
    }
    //-------------------------------------------------------------------------------------------------------------------------------------------
  } else {        //РЕЖИМ ОБЫЧНОЙ АСИНХРОННОЙ ПОДАЧИ
    //Три условия выполнения участка кода:
    //Мотор оси Z достиг Левого лимита (Независимо от положения ручки джойстика программная команда на СТОП)
    //Мотор оси Z достиг Правого лимита (Независимо от положения ручки джойстика программная команда на СТОП)
    //Погашен флаг работы по оси Z (обычно от ручки джойстика в нейтральном положении)
    if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Z_NEED_RUN_FEED_FLAG) )
    {
      //Участок замедления, торможения скорости вращения мотора по оси Z (до минимальной заданной)
      if (OCR4A < max_OCR4A)
      {
        Motor_Z_InvertPulse();                  //Смена состояния линии PULSE оси Z
#ifdef _DEBUG_INTERRUPT
        Serial.print("Z4C\n\r");       //DEBUG
#endif
        //Serial.print("Motor_Z_InvertPulse\n\r");
        if (!Read_Z_State)                      //Выполняем через раз - когда Read_Z_State возвращает false
        {
          OCR4A ++;                             //Замедление, торможение, снижение скорости вращения - путём снижения частоты работы таймера OCR4A
          if (Motor_Z_Dir == CW) {              //Выясняем текущее направление вращения мотора оси Z
            Motor_Z_Pos ++;                     //Учёт, подсчёт импульса в зависимости от направления вращения
          } else {
            Motor_Z_Pos --;                     //Учёт, подсчёт импульса в зависимости от направления вращения
          }
        }
      }
      else      //по достижению минимальной заданной скорости - выключаются флаги работы моторов по всем осям
      {
        Z_WORKING_FEED_FLAG = OFF;                      //После выполнения торможения - зажигаем флаги остановки (вернее гасим флаги работы по оси Z)
        X_WORKING_FEED_FLAG = OFF;                      //После выполнения торможения - зажигаем флаги остановки (вернее гасим флаги работы по оси X)
      }
    }
    else
    {
      Z_WORKING_FEED_FLAG = ON;                         //Зажигаем флаг работы по оси Z
      Motor_Z_InvertPulse();                    //Смена состояния линии PULSE оси Z
#ifdef _DEBUG_INTERRUPT
      Serial.print("Z4C\n\r");       //DEBUG
#endif
      //Serial.print("Motor_Z_InvertPulse\n\r");
      if (!Read_Z_State)                        //Выполняем через раз - когда Read_Z_State возвращает false
      {
        if (Motor_Z_Dir == CW) {                //Выясняем текущее направление вращения мотора оси Z
          Motor_Z_Pos ++;                       //Учёт, подсчёт импульса в зависимости от направления вращения
        } else {
          Motor_Z_Pos --;                       //Учёт, подсчёт импульса в зависимости от направления вращения
        }
        if (OCR4A > aFeed_Divisor) {            //Сравнение текущей частоты таймера OCR4 с заданной частотой aFeed_Divisor (зависит от положения ручки переменного резистора подач)
          OCR4A --;                             //Ускорение, разгон, набор скорости вращения - путём увеличения частоты работы таймера OCR4A
        } else if (OCR4A < aFeed_Divisor) {
          OCR4A ++;                             //Замедление, торможение, снижение скорости вращения - путём снижения частоты работы таймера OCR4A
        }
      }
    }

  }
  //}
  //-------------------------------------------------------------------------------------------------------------------------------------------
AXIS_X:
  //Отдельно для конусов
  //if (Mode == Mode_Cone_L || Mode == Mode_Cone_R)
  //{
  //Это для режима Конусов (т.к. только в них при активном Z активен ещё и X_WORKING_FEED_FLAG == ON)

  if (X_WORKING_FEED_FLAG == ON)
  {

    if (XZ_Divisor == (byte)1)
    {
      Motor_X_InvertPulse();                    //Смена состояния линии PULSE оси X
#ifdef _DEBUG_INTERRUPT
      Serial.print("X4C\n\r");       //DEBUG
#endif
      //Serial.print("Motor_Z_InvertPulse\n\r");
      if (!Read_X_State)                        //Выполняем через раз - когда Read_Z_State возвращает false
      {
        if (Motor_X_Dir == CW) {                //Выясняем текущее направление вращения мотора оси Z
          Motor_X_Pos ++;                       //Учёт, подсчёт импульса в зависимости от направления вращения
        } else {
          Motor_X_Pos --;                       //Учёт, подсчёт импульса в зависимости от направления вращения
        }
      }
    } else {



      if (++Cs_Count > Cs_Divisor)            //Если текущий счётчик целой части конуса больше Коэффициента конуса из таблицы конусов (целая часть)
      {
        //Motor_X_SetPulse();                   //Повышаем уровень сигнала STEP линии мотора X
        //Serial.print("Motor_X_SetPulse\n\r");
        if (Motor_X_Dir == CW) {
          Motor_X_Pos ++;                     //Производим учёт импульса мотора Х в зависимости от направления его вращения
        } else {
          Motor_X_Pos --;                     //Производим учёт импульса мотора Х в зависимости от направления его вращения
        }
        Cm_Count = Cm_Count + Cm_Divisor;     //
        if (Cm_Count > Cm_Divisor) {          //
          Cm_Count = Cm_Count - 10000;        //
          Cs_Count = 0;                       //Сброс Cs_Count до 0
        } else {
          Cs_Count = 1;                       //Иначе сброс Cs_Count до 1
        }
        Motor_X_SetPulse();                   //Повышаем уровень сигнала STEP линии мотора X (Перенесли сюда, лишние миллисекунды чтобы были 0 сигнала до включения Х)
#ifdef _DEBUG_INTERRUPT
        Serial.print("X4C\n\r");       //DEBUG
#endif
        //DEBUG Отладка импульсов в режиме Конусов (строка выводится синхронно с подачей импульса мотору оси Х)
        //unsigned int __TCNT4 = TCNT4;


        //Если коэффициент конуса меньше 2.0000, то частоты не хватает и импульсы получаются слишком короткими
        if (Cs_Divisor < (byte)2)
        {
          MotorX_NeedClear = true;
        }
        //Serial.print("TCNT4="); Serial.print(__TCNT4); Serial.print("\n\r");
        // Serial.print("Cone:"); Serial.print(Cs_Divisor); Serial.print("."); Serial.print(Cm_Divisor); Serial.print("=>"); Serial.print(Cs_Count); Serial.print("."); Serial.print(Cm_Count); Serial.print("\n\r");
      }
    }

  }
  //}
}

//===================================================================================================================================================================================================
//==============                 Обработчик таймера TIMER5_COMPA                 ====================================================================================================================
//==============              РЕЖИМ "СИНХРОННАЯ ПОДАЧА" (Feed) ОСЬ Z             ====================================================================================================================
//==============   Таймер-5 синхронный, получает импульсы от энкодера шпинделя   ====================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER5_COMPA_vect)
{
  //Serial.print("5A\n\r");
  if (Joy_Z_flag == ON) {
    Motor_X_RemovePulse();
  }

  TachoRemovePulse();
  Tacho_Count = Tacho_Count + (OCR5A + 1);
  if (Tacho_Count > ENC_LINE_PER_REV)
  {
    TachoSetPulse();
    Tacho_Count = Tacho_Count - ENC_LINE_PER_REV;
  }

  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]
  bool bRapid = false;

  if (SpeedMode == FORCE_RAPID)
  {
    //Режим работы постоянный Rapid - аналог функции который у Олега работал на OCR2A таймере - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах и при запуске с включённой кнопкой RapidButton)
    bRapid = true;
  } else if (SpeedMode == FORCE_SLOW)
  {
    //Режим работы постоянный Slow - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах)
    bRapid = false;
  } else {
    //Режим работы Manual - производит опрос кнопки RapidButton и переключается между режимами Rapid и Slow, можно прямо во время работы
    //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]

    /*
      //Сначала проверка условия на кнопку ускоренной подачи. Истинно, если кнопка "Быстрая подача" не нажата.
      if (Button_Rapid_Not_Pressed)                           //КНОПКА "БЫСТРАЯ ПОДАЧА" не нажата
      {
      if (Z_NEED_RUN_RAPID_FLAG == ON && Z_WORKING_RAPID_FLAG == ON)    //Если мотор Z не в простое, а был в работе, в режиме подача:
      {
        Z_WORKING_FEED_FLAG = ON;                                   //то включаем флаги режима обычной подачи
        Z_NEED_RUN_FEED_FLAG = ON;
        Z_NEED_RUN_RAPID_FLAG = OFF;                                 //и выключаем флаги быстрой подачи (это можно делать прям на ходу)
        Z_WORKING_RAPID_FLAG = OFF;
      } else if (Z_NEED_RUN_RAPID_FLAG == ON && Z_NEED_RUN_FEED_FLAG == OFF)  //Это "костыль" - когда нажат Рапид и двигатель доехал до лимита, и рапид отпускают, а джой всё-ещё в положении движения - чтобы мотор не сдвинулся с лимита (не переключился на торможение в режиме подача)
      {
        OCR5A = max_OCR5A;    //Чтобы мотор при переходе с быстрой подачи на обычную при достижении лимита не "тормозил" повторно и не выезжал за лимит
      }
      } else {                                                //КНОПКА "БЫСТРАЯ ПОДАЧА" нажата
      if (Z_WORKING_FEED_FLAG == ON && Z_NEED_RUN_FEED_FLAG == ON)           //Если мотор Z не в простое, а был в работе, в режиме подача:
      {
        Z_WORKING_FEED_FLAG = OFF;                                  //то выключаем флаги режима обычной подачи
        Z_NEED_RUN_FEED_FLAG = OFF;
        Z_NEED_RUN_RAPID_FLAG = ON;                                  //и включаем флаги в режим быстрой подачи (это можно делать прям на ходу)
        Z_WORKING_RAPID_FLAG = ON;
      }
      bRapid = true;                                        //Обнаружено нажатие на кнопку ускоренной подачи, взводим флаг и в дальнейшем используем этот флаг вместо чтения пина кнопки
      }
    */

  }

  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Таймер5A для режима Feed
  if (Mode == Mode_Feed)
  {
    if (bRapid)       //РЕЖИМ БЫСТРОЙ СИНХРОННОЙ ПОДАЧИ
    {
      //-------------------------------------------------------------------------------------------------------------------------------------------
      if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Z_NEED_RUN_RAPID_FLAG) )
      {
        if (OCR5A < (unsigned int)MIN_RAPID_MOTION)               //Переделка OCR2A -> OCR5A (unsigned int)
        {
          Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
          Serial.print("Z5A\n\r");       //DEBUG
#endif
          //Serial.print("Motor_Z_InvertPulse\n\r");
          if (!Read_Z_State)
          {
            if (Motor_Z_Dir == CW) {
              Motor_Z_Pos ++;
            } else {
              Motor_Z_Pos --;
            }
            if (++Repeat_Count >= REPEAt)                           //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR5A ++;                                             //Переделка OCR2A -> OCR5A
            }
          }
        } else {
          Z_WORKING_RAPID_FLAG = OFF;
          X_WORKING_FEED_FLAG = OFF;
        }
      }
      else
      {
        Z_WORKING_RAPID_FLAG = ON;
        Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("Z5A\n\r");       //DEBUG
#endif
        //Serial.print("Motor_Z_InvertPulse\n\r");
        if (!Read_Z_State)
        {
          if (Motor_Z_Dir == CW) {
            Motor_Z_Pos ++;
          } else {
            Motor_Z_Pos --;
          }
          if (OCR5A > (unsigned int)MAX_RAPID_MOTION)                 //Переделка OCR2A -> OCR5A (unsigned int)
          {
            if (++Repeat_Count >= REPEAt)                             //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR5A --;                                               //Переделка OCR2A -> OCR5A
            }
          }
        }
      }
      //-------------------------------------------------------------------------------------------------------------------------------------------
    } else {        //РЕЖИМ ОБЫЧНОЙ СИНХРОННОЙ ПОДАЧИ
      if ( (Motor_Z_Dir == CW && Motor_Z_Pos > Limit_Pos) || (Motor_Z_Dir == CCW && Motor_Z_Pos < Limit_Pos) || (!Z_NEED_RUN_FEED_FLAG) )
      {
        if (OCR5A < max_OCR5A)
        {
          Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
          Serial.print("Z5A\n\r");       //DEBUG
#endif
          if (!Read_Z_State)
          {
            OCR5A++;
            if (Motor_Z_Dir == CW) {
              Motor_Z_Pos ++;
            } else {
              Motor_Z_Pos --;
            }
          }
        } else {
          Z_WORKING_FEED_FLAG = OFF;
          X_WORKING_FEED_FLAG = OFF;
        }
      }
      else
      {
        Z_WORKING_FEED_FLAG = ON;
        Motor_Z_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("Z5A\n\r");       //DEBUG
#endif
        if (!Read_Z_State)
        {
          if (Motor_Z_Dir == CW) {
            Motor_Z_Pos ++;
          } else {
            Motor_Z_Pos --;
          }
          if (OCR5A > Feed_Divisor) {
            OCR5A--;
          } else if (OCR5A < Feed_Divisor) {
            OCR5A ++;
          }
        }
      }
    }
  }
  //-------------------------------------------------------------------------------------------------------------------------------------------
}

//===================================================================================================================================================================================================
//==============                 Обработчик таймера TIMER5_COMPB                 ====================================================================================================================
//==============              РЕЖИМ "СИНХРОННАЯ ПОДАЧА" (Feed) ОСЬ X             ====================================================================================================================
//==============   Таймер-5 синхронный, получает импульсы от энкодера шпинделя   ====================================================================================================================
//===================================================================================================================================================================================================
ISR (TIMER5_COMPB_vect)
{
  //Serial.print("5B\n\r");

  TachoRemovePulse();
  Tacho_Count = Tacho_Count + (OCR5A + 1);
  if (Tacho_Count > ENC_LINE_PER_REV)
  {
    TachoSetPulse();
    Tacho_Count = Tacho_Count - ENC_LINE_PER_REV;
  }

  //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]
  bool bRapid = false;



  if (SpeedMode == FORCE_RAPID)
  {
    //Режим работы постоянный Rapid - аналог функции который у Олега работал на OCR2A таймере - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах и при запуске с включённой кнопкой RapidButton)
    bRapid = true;
  } else if (SpeedMode == FORCE_SLOW)
  {
    //Режим работы постоянный Slow - в процессе работы нажатия на кнопку RapidButton игнорируются (используется в автоматических режимах)
    bRapid = false;
  } else {
    //Режим работы Manual - производит опрос кнопки RapidButton и переключается между режимами Rapid и Slow, можно прямо во время работы
    //Проверка нажатия на кнопку Ускоренной подачи [пока без фильтрации дребезга кнопки]

    /*
      //Сначала проверка условия на кнопку ускоренной подачи. Истинно, если кнопка "Быстрая подача" не нажата.
      if (Button_Rapid_Not_Pressed)                           //КНОПКА "БЫСТРАЯ ПОДАЧА" не нажата
      {
      if (X_NEED_RUN_RAPID_FLAG == ON && X_WORKING_RAPID_FLAG == ON)    //Если мотор X не в простое, а был в работе, в режиме подача:
      {
        X_WORKING_FEED_FLAG = ON;                                   //то включаем флаги режима обычной подачи
        X_NEED_RUN_FEED_FLAG = ON;
        X_NEED_RUN_RAPID_FLAG = OFF;                                 //и выключаем флаги быстрой подачи (это можно делать прям на ходу)
        X_WORKING_RAPID_FLAG = OFF;
      }
      } else {                                                //КНОПКА "БЫСТРАЯ ПОДАЧА" нажата
      if (X_WORKING_FEED_FLAG == ON && X_NEED_RUN_FEED_FLAG == ON)           //Если мотор X не в простое, а был в работе, в режиме подача:
      {
        X_WORKING_FEED_FLAG = OFF;                                  //то выключаем флаги режима обычной подачи
        X_NEED_RUN_FEED_FLAG = OFF;
        X_NEED_RUN_RAPID_FLAG = ON;                                  //и включаем флаги в режим быстрой подачи (это можно делать прям на ходу)
        X_WORKING_RAPID_FLAG = ON;
      }
      bRapid = true;                                        //Обнаружено нажатие на кнопку ускоренной подачи, взводим флаг и в дальнейшем используем этот флаг вместо чтения пина кнопки
      }
    */

  }
  //-------------------------------------------------------------------------------------------------------------------------------------------
  //Таймер5 для режима Feed
  if (Mode == Mode_Feed)
  {
    if (bRapid)       //РЕЖИМ БЫСТРОЙ ПОДАЧИ
    {
      //--------------------------------------------------------------------------------------------------------------------------------------------
      if ( (Motor_X_Dir == CW && Motor_X_Pos > Limit_Pos) || (Motor_X_Dir == CCW && Motor_X_Pos < Limit_Pos) || (!X_NEED_RUN_RAPID_FLAG) )
      {
        if (OCR5A < (unsigned int)MIN_RAPID_MOTION)     //OCR2A -> OCR5A + ->(unsigned int)
        {
          Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
          Serial.print("X5B\n\r");       //DEBUG
#endif
          if (!Read_X_State)
          {
            if (Motor_X_Dir == CW) {
              Motor_X_Pos ++;
            } else {
              Motor_X_Pos --;
            }
            if (++Repeat_Count >= REPEAt)                 //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR5A ++;
            }
          }
        } else {
          X_WORKING_RAPID_FLAG = OFF;
        }
      }
      else
      {
        X_WORKING_RAPID_FLAG = ON;
        Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("X5B\n\r");       //DEBUG
#endif
        if (!Read_X_State)
        {
          if (Motor_X_Dir == CW) {
            Motor_X_Pos ++;
          }
          else {
            Motor_X_Pos --;
          }
          if (OCR5A > (unsigned int)MAX_RAPID_MOTION)     //OCR2A -> OCR5A + ->(unsigned int)
          {
            if (++Repeat_Count >= REPEAt)       //Opti: вместо == используется >= без увеличения размера кода
            {
              Repeat_Count = 0;
              OCR5A --;
            }
          }
        }
      }
      //--------------------------------------------------------------------------------------------------------------------------------------------
    } else {       //РЕЖИМ ОБЫЧНОЙ СИНХРОННОЙ ПОДАЧИ
      if ( (Motor_X_Dir == CW && Motor_X_Pos > Limit_Pos) || (Motor_X_Dir == CCW && Motor_X_Pos < Limit_Pos) || (!X_NEED_RUN_FEED_FLAG) )
      {
        if (OCR5A < max_OCR5A)
        {
          Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
          Serial.print("X5B\n\r");       //DEBUG
#endif
          if (!Read_X_State)
          {
            OCR5A++;
            if (Motor_X_Dir == CW) {
              Motor_X_Pos ++;
            } else {
              Motor_X_Pos --;
            }
          }
        } else {
          X_WORKING_FEED_FLAG = OFF;
        }
      }
      else
      {
        X_WORKING_FEED_FLAG = ON;
        Motor_X_InvertPulse();
#ifdef _DEBUG_INTERRUPT
        Serial.print("X5B\n\r");       //DEBUG
#endif
        {
          if (!Read_X_State)
          {
            if (Motor_X_Dir == CW) {
              Motor_X_Pos ++;
            } else {
              Motor_X_Pos --;
            }
            if (OCR5A > Feed_Divisor) {
              OCR5A--;
            } else if (OCR5A < Feed_Divisor) {
              OCR5A ++;
            }
          }
        }
      }
    }
  }

}
